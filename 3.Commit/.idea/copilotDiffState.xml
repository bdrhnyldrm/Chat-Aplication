<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;@Configuration&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder(); //burada BCRYPT algoritması kullanarak şifreyi hashledik.&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf(csrf -&gt; csrf.disable())&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .anyRequest().permitAll()&#10;                );&#10;&#10;        return http.build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;@Configuration // Bu sınıfın bir Spring yapılandırma sınıfı olduğunu belirtir.&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        // Şifreleme için BCrypt algoritmasını kullanan bir PasswordEncoder bean'i tanımlar.&#10;        return new BCryptPasswordEncoder(); // Şifreleri güvenli bir şekilde hashlemek için kullanılır.&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        // Uygulamanın güvenlik yapılandırmasını tanımlar.&#10;        http&#10;                .csrf(csrf -&gt; csrf.disable()) // CSRF korumasını devre dışı bırakır (örnek amaçlı, üretimde dikkatli olunmalıdır).&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .anyRequest().permitAll() // Tüm HTTP isteklerine izin verir (herkese açık erişim).&#10;                );&#10;&#10;        return http.build(); // Güvenlik yapılandırmasını oluşturur ve döndürür.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/WebSocketConfig.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.*;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        config.enableSimpleBroker(&quot;/topic&quot;); // mesaj dinleme kanalı&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;); // mesaj gönderme kanalı&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        registry.addEndpoint(&quot;/chat&quot;) // bağlantı noktası&#10;                .setAllowedOriginPatterns(&quot;*&quot;) // CORS&#10;                .withSockJS(); // SockJS fallback&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.*;&#10;&#10;@Configuration // Bu sınıfın bir Spring yapılandırma sınıfı olduğunu belirtir.&#10;@EnableWebSocketMessageBroker // WebSocket mesajlaşma desteğini etkinleştirir.&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        config.enableSimpleBroker(&quot;/topic&quot;); // Mesajların dinleneceği kanalın ön ekini tanımlar.&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;); // Mesajların gönderileceği kanalın ön ekini tanımlar.&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        registry.addEndpoint(&quot;/chat&quot;) // WebSocket bağlantısı için kullanılacak endpoint'i tanımlar.&#10;                .setAllowedOriginPatterns(&quot;*&quot;) // CORS yapılandırması: Tüm kaynaklara izin verir.&#10;                .withSockJS(); // SockJS desteği ekler, WebSocket desteklenmeyen tarayıcılar için yedek çözüm.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/ChatController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/ChatController.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.messaging.handler.annotation.*;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.stereotype.Controller;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Controller // Bu sınıfın bir Spring Controller olduğunu belirtir.&#10;public class ChatController {&#10;&#10;    @Autowired // Spring tarafından SimpMessagingTemplate bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private SimpMessagingTemplate messagingTemplate; // Mesajları belirli bir hedefe göndermek için kullanılır.&#10;&#10;    @Autowired // Spring tarafından ChatMessageRepository bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private ChatMessageRepository chatMessageRepository; // Mesajları veritabanına kaydetmek için kullanılır.&#10;&#10;    @MessageMapping(&quot;/chat&quot;) // Gelen mesajları /app/chat endpoint'inde dinler.&#10;    public void sendMessage(@Payload ChatMessage message) {&#10;        message.setTimestamp(LocalDateTime.now()); // Mesajın gönderildiği zamanı ayarlar.&#10;        message.setStatus(&quot;SENT&quot;); // Mesajın durumunu &quot;SENT&quot; olarak ayarlar.&#10;&#10;        chatMessageRepository.save(message); // Mesajı veritabanına kaydeder.&#10;&#10;        // Gönderilen mesajı, alıcının dinlediği kanala iletir.&#10;        messagingTemplate.convertAndSend(&#10;                &quot;/topic/messages/&quot; + message.getReceiver(), // Alıcının dinlediği kanal.&#10;                message // Gönderilecek mesaj.&#10;        );&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.messaging.handler.annotation.*;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.stereotype.Controller;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Controller // Bu sınıfın bir Spring Controller olduğunu belirtir.&#10;public class ChatController {&#10;&#10;    @Autowired // Spring tarafından SimpMessagingTemplate bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private SimpMessagingTemplate messagingTemplate; // Mesajları belirli bir hedefe göndermek için kullanılır.&#10;&#10;    @Autowired // Spring tarafından ChatMessageRepository bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private ChatMessageRepository chatMessageRepository; // Mesajları veritabanına kaydetmek için kullanılır.&#10;&#10;    @MessageMapping(&quot;/chat&quot;) // Gelen mesajları /app/chat endpoint'inde dinler.&#10;    public void sendMessage(@Payload ChatMessage message) {&#10;        message.setTimestamp(LocalDateTime.now()); // Mesajın gönderildiği zamanı ayarlar.&#10;        message.setStatus(&quot;SENT&quot;); // Mesajın durumunu &quot;SENT&quot; olarak ayarlar.&#10;&#10;        chatMessageRepository.save(message); // Mesajı veritabanına kaydeder.&#10;&#10;        // Alıcıya mesaj gönder&#10;        messagingTemplate.convertAndSend(&#10;            &quot;/topic/messages/&quot; + message.getReceiver(), // Alıcının dinlediği kanal.&#10;            message // Gönderilecek mesaj.&#10;        );&#10;&#10;        // Gönderene de mesajı geri gönder (kendi ekranında anında görsün)&#10;        messagingTemplate.convertAndSend(&#10;            &quot;/topic/messages/&quot; + message.getSender(), // Gönderenin dinlediği kanal.&#10;            message // Gönderilecek mesaj.&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/MessageRestController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/MessageRestController.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/messages&quot;)&#10;public class MessageRestController {&#10;&#10;    @Autowired&#10;    private ChatMessageRepository chatMessageRepository;&#10;&#10;    @Autowired&#10;    private SimpMessagingTemplate messagingTemplate; // WebSocket status mesajı gönderenin kanalına tekrar göndermek için&#10;&#10;    @GetMapping(&quot;/{user1}/{user2}&quot;)&#10;    public List&lt;ChatMessage&gt; getChatHistory(@PathVariable String user1, @PathVariable String user2) {&#10;        List&lt;ChatMessage&gt; sent = chatMessageRepository.findBySenderAndReceiver(user1, user2);&#10;        List&lt;ChatMessage&gt; received = chatMessageRepository.findBySenderAndReceiver(user2, user1);&#10;&#10;        sent.addAll(received);&#10;        sent.sort(Comparator.comparing(ChatMessage::getTimestamp));&#10;&#10;        return sent;&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}/read&quot;)&#10;    public ResponseEntity&lt;String&gt; markAsRead(@PathVariable Long id) {&#10;        return chatMessageRepository.findById(id)&#10;                .map(msg -&gt; {&#10;                    msg.setStatus(&quot;READ&quot;);&#10;                    chatMessageRepository.save(msg);&#10;&#10;                    // Gönderen kullanıcıya güncellenmiş mesajı gönder (WebSocket ile)&#10;                    messagingTemplate.convertAndSend(&#10;                            &quot;/topic/messages/&quot; + msg.getSender(),&#10;                            msg&#10;                    );&#10;&#10;                    return ResponseEntity.ok(&quot;Mesaj okundu olarak işaretlendi&quot;);&#10;                })&#10;                .orElse(ResponseEntity.notFound().build());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.controller;&#13;&#10;&#13;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#13;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#13;&#10;import org.springframework.beans.factory.annotation.Autowired;&#13;&#10;import org.springframework.http.ResponseEntity;&#13;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;&#13;&#10;import java.util.Comparator;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@RestController&#13;&#10;@RequestMapping(&quot;/messages&quot;)&#13;&#10;public class MessageRestController {&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private ChatMessageRepository chatMessageRepository;&#13;&#10;&#13;&#10;    @Autowired&#13;&#10;    private SimpMessagingTemplate messagingTemplate; // WebSocket status mesajı gönderenin kanalına tekrar göndermek için&#13;&#10;&#13;&#10;    @GetMapping(&quot;/{user1}/{user2}&quot;)&#13;&#10;    public List&lt;ChatMessage&gt; getChatHistory(@PathVariable String user1, @PathVariable String user2) {&#13;&#10;        List&lt;ChatMessage&gt; sent = chatMessageRepository.findBySenderAndReceiver(user1, user2);&#13;&#10;        List&lt;ChatMessage&gt; received = chatMessageRepository.findBySenderAndReceiver(user2, user1);&#13;&#10;&#13;&#10;        sent.addAll(received);&#13;&#10;        sent.sort(Comparator.comparing(ChatMessage::getTimestamp));&#13;&#10;&#13;&#10;        return sent;&#13;&#10;    }&#13;&#10;&#13;&#10;    @PutMapping(&quot;/{id}/read&quot;)&#13;&#10;    public ResponseEntity&lt;String&gt; markAsRead(@PathVariable Long id) {&#13;&#10;        return chatMessageRepository.findById(id)&#13;&#10;                .map(msg -&gt; {&#13;&#10;                    msg.setStatus(&quot;READ&quot;);&#13;&#10;                    chatMessageRepository.save(msg);&#13;&#10;&#13;&#10;                    // Gönderen kullanıcıya güncellenmiş mesajı gönder (WebSocket ile)&#13;&#10;                    messagingTemplate.convertAndSend(&#13;&#10;                            &quot;/topic/messages/&quot; + msg.getSender(),&#13;&#10;                            msg&#13;&#10;                    );&#13;&#10;&#13;&#10;                    return ResponseEntity.ok(&quot;Mesaj okundu olarak işaretlendi&quot;);&#13;&#10;                })&#13;&#10;                .orElse(ResponseEntity.notFound().build());&#13;&#10;    }&#13;&#10;&#13;&#10;    @PutMapping(&quot;/mark-all-read/{username}&quot;)&#13;&#10;    public ResponseEntity&lt;String&gt; markAllMessagesAsRead(@PathVariable String username) {&#13;&#10;        List&lt;ChatMessage&gt; unreadMessages = chatMessageRepository.findByReceiverAndStatus(username, &quot;SENT&quot;);&#13;&#10;&#13;&#10;        for (ChatMessage msg : unreadMessages) {&#13;&#10;            msg.setStatus(&quot;READ&quot;);&#13;&#10;            chatMessageRepository.save(msg);&#13;&#10;&#13;&#10;            // Gönderen kullanıcıya da güncel status ile geri gönder&#13;&#10;            messagingTemplate.convertAndSend(&#13;&#10;                &quot;/topic/messages/&quot; + msg.getSender(),&#13;&#10;                msg&#13;&#10;            );&#13;&#10;        }&#13;&#10;&#13;&#10;        return ResponseEntity.ok(&quot;Tüm okunmamış mesajlar güncellendi&quot;);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/model/ChatMessage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/model/ChatMessage.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Table(name = &quot;messages&quot;)&#10;public class ChatMessage {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    private String sender;&#10;    private String receiver;&#10;    private String content;&#10;&#10;    private LocalDateTime timestamp;&#10;&#10;    private String status; // örn: SENT, DELIVERED, READ&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity // Bu sınıfın bir JPA varlık sınıfı olduğunu belirtir.&#10;@Data // Lombok tarafından getter, setter, toString, equals ve hashCode metodlarını otomatik oluşturur.&#10;@NoArgsConstructor // Parametresiz bir yapıcı metod oluşturur.&#10;@AllArgsConstructor // Tüm alanları içeren bir yapıcı metod oluşturur.&#10;@Builder // Builder tasarım desenini kullanarak nesne oluşturmayı sağlar.&#10;@Table(name = &quot;messages&quot;) // Bu varlığın veritabanında &quot;messages&quot; tablosuna karşılık geldiğini belirtir.&#10;public class ChatMessage {&#10;&#10;    @Id // Bu alanın birincil anahtar olduğunu belirtir.&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY) // Birincil anahtarın otomatik olarak artırılacağını belirtir.&#10;    private Long id; // Mesajın benzersiz kimliği.&#10;&#10;    private String sender; // Mesajı gönderen kişinin kullanıcı adı veya kimliği.&#10;    private String receiver; // Mesajın alıcısının kullanıcı adı veya kimliği.&#10;    private String content; // Mesajın içeriği.&#10;&#10;    private LocalDateTime timestamp; // Mesajın gönderildiği tarih ve saat.&#10;&#10;    private String status; // Mesajın durumu (örneğin: SENT, DELIVERED, READ).&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/repository/ChatMessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/repository/ChatMessageRepository.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.repository;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.List;&#10;&#10;public interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;    // JpaRepository, ChatMessage varlığı için temel CRUD işlemlerini sağlar.&#10;&#10;    List&lt;ChatMessage&gt; findBySenderAndReceiver(String sender, String receiver);&#10;    // Belirli bir gönderici ve alıcı arasındaki mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiverAndSender(String receiver, String sender);&#10;    // Belirli bir alıcı ve gönderici arasındaki mesajları döndürür (ters yönlü sorgu).&#10;&#10;    List&lt;ChatMessage&gt; findBySender(String sender);&#10;    // Belirli bir gönderici tarafından gönderilen tüm mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiver(String receiver);&#10;    // Belirli bir alıcıya gönderilen tüm mesajları döndürür.&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.repository;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.List;&#10;&#10;public interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;    // JpaRepository, ChatMessage varlığı için temel CRUD işlemlerini sağlar.&#10;&#10;    List&lt;ChatMessage&gt; findBySenderAndReceiver(String sender, String receiver);&#10;    // Belirli bir gönderici ve alıcı arasındaki mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiverAndSender(String receiver, String sender);&#10;    // Belirli bir alıcı ve gönderici arasındaki mesajları döndürür (ters yönlü sorgu).&#10;&#10;    List&lt;ChatMessage&gt; findBySender(String sender);&#10;    // Belirli bir gönderici tarafından gönderilen tüm mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiver(String receiver);&#10;    // Belirli bir alıcıya gönderilen tüm mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiverAndStatus(String receiver, String status);&#10;    // Belirli bir alıcı ve durum için mesajları döndürür.&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/resources/static/chat.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/resources/static/chat.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;tr&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Sohbet&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&#10;&lt;h2&gt; Gerçek Zamanlı Sohbet&lt;/h2&gt;&#10;&#10;&lt;p id=&quot;greeting&quot;&gt;&lt;/p&gt;&#10;&#10;&lt;div style=&quot;display: flex; gap: 50px;&quot;&gt;&#10;  &lt;div&gt;&#10;    &lt;h4&gt; Kişi Listesi&lt;/h4&gt;&#10;    &lt;ul id=&quot;user-list&quot;&gt;&lt;/ul&gt;&#10;  &lt;/div&gt;&#10;  &lt;div&gt;&#10;    &lt;h4&gt; Sohbet Geçmişi&lt;/h4&gt;&#10;    &lt;ul id=&quot;conversation-list&quot;&gt;&lt;/ul&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;&lt;hr&gt;&#10;&#10;&lt;label&gt;Alıcı: &lt;input type=&quot;text&quot; id=&quot;receiver&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#10;&lt;label&gt;Mesaj: &lt;input type=&quot;text&quot; id=&quot;message&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#10;&lt;button onclick=&quot;sendMessage()&quot;&gt;Gönder&lt;/button&gt;&#10;&#10;&lt;hr&gt;&#10;&lt;div id=&quot;chat-box&quot;&gt;&lt;/div&gt;&#10;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js&quot;&gt;&lt;/script&gt;&#10;&#10;&lt;script&gt;&#10;    let stompClient = null;&#10;    let currentUser = &quot;&quot;;&#10;&#10;    // URL'den kullanıcı adını al&#10;    const urlParams = new URLSearchParams(window.location.search);&#10;    currentUser = urlParams.get(&quot;user&quot;);&#10;&#10;    if (!currentUser) {&#10;      alert(&quot;Kullanıcı adı bulunamadı. Lütfen giriş yapın.&quot;);&#10;      window.location.href = &quot;/login.html&quot;;&#10;    }&#10;&#10;    document.getElementById(&quot;greeting&quot;).innerText = `${currentUser} olarak giriş yaptınız.`;&#10;&#10;    function connectWebSocket() {&#10;      const socket = new SockJS(&quot;/chat&quot;);&#10;      stompClient = Stomp.over(socket);&#10;&#10;      stompClient.connect({}, function () {&#10;        stompClient.subscribe(&quot;/topic/messages/&quot; + currentUser, function (message) {&#10;          const msg = JSON.parse(message.body);&#10;          const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;          const chatBox = document.getElementById(&quot;chat-box&quot;);&#10;&#10;          // Eğer aynı mesaj daha önce eklendiyse tekrar gösterme&#10;          if (!document.getElementById(&quot;msg-&quot; + msg.id)) {&#10;            const p = document.createElement(&quot;p&quot;);&#10;            p.id = &quot;msg-&quot; + msg.id;&#10;            p.innerText = display;&#10;            chatBox.appendChild(p);&#10;          } else {&#10;            // Mevcutsa sadece status'ü güncelle&#10;            const existing = document.getElementById(&quot;msg-&quot; + msg.id);&#10;            existing.innerText = display;&#10;          }&#10;&#10;          // Eğer bu mesajın alıcısı bu kullanıcıysa ve henüz READ değilse → READ yap&#10;          if (msg.receiver === currentUser &amp;&amp; msg.status !== &quot;READ&quot;) {&#10;            fetch(`/messages/${msg.id}/read`, { method: &quot;PUT&quot; });&#10;          }&#10;        });&#10;&#10;        // Kullanıcı listelerini yükle&#10;        loadUserLists();&#10;      });&#10;    }&#10;&#10;    function loadUserLists() {&#10;      // Kişi listesi&#10;      fetch(`/users/all/${currentUser}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          const userList = document.getElementById(&quot;user-list&quot;);&#10;          userList.innerHTML = &quot;&quot;;&#10;          data.forEach(user =&gt; {&#10;            const li = document.createElement(&quot;li&quot;);&#10;            li.innerText = user;&#10;            li.style.cursor = &quot;pointer&quot;;&#10;            li.onclick = () =&gt; {&#10;              document.getElementById(&quot;receiver&quot;).value = user;&#10;              loadChatHistory(user);&#10;            };&#10;            userList.appendChild(li);&#10;          });&#10;        });&#10;&#10;      // Sohbet geçmişi&#10;      fetch(`/users/conversations/${currentUser}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          const convList = document.getElementById(&quot;conversation-list&quot;);&#10;          convList.innerHTML = &quot;&quot;;&#10;          data.forEach(user =&gt; {&#10;            const li = document.createElement(&quot;li&quot;);&#10;            li.innerText = user;&#10;            li.style.cursor = &quot;pointer&quot;;&#10;            li.onclick = () =&gt; {&#10;              document.getElementById(&quot;receiver&quot;).value = user;&#10;              loadChatHistory(user);&#10;            };&#10;            convList.appendChild(li);&#10;          });&#10;        });&#10;    }&#10;&#10;    function loadChatHistory(receiver) {&#10;      document.getElementById(&quot;chat-box&quot;).innerHTML = &quot;&quot;;&#10;&#10;      fetch(`/messages/${currentUser}/${receiver}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          data.forEach(msg =&gt; {&#10;            const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;            document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;          });&#10;        });&#10;    }&#10;&#10;    function sendMessage() {&#10;      if (!currentUser) {&#10;        alert(&quot;Giriş yapmadan mesaj gönderemezsiniz.&quot;);&#10;        return;&#10;      }&#10;&#10;      const receiver = document.getElementById(&quot;receiver&quot;).value;&#10;      const content = document.getElementById(&quot;message&quot;).value;&#10;&#10;      if (!receiver || !content) {&#10;        alert(&quot;Alıcı ve mesaj boş olamaz.&quot;);&#10;        return;&#10;      }&#10;&#10;      stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({&#10;        sender: currentUser,&#10;        receiver: receiver,&#10;        content: content&#10;      }));&#10;&#10;      // Mesaj kutusunu temizle&#10;      document.getElementById(&quot;message&quot;).value = &quot;&quot;;&#10;    }&#10;&#10;    connectWebSocket(); // Sayfa yüklenince otomatik bağlan&#10;&lt;/script&gt;&#10;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;tr&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Sohbet&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&#10;&lt;h2&gt; Gerçek Zamanlı Sohbet&lt;/h2&gt;&#10;&#10;&lt;p id=&quot;greeting&quot;&gt;&lt;/p&gt;&#10;&#10;&lt;div style=&quot;display: flex; gap: 50px;&quot;&gt;&#10;  &lt;div&gt;&#10;    &lt;h4&gt; Kişi Listesi&lt;/h4&gt;&#10;    &lt;ul id=&quot;user-list&quot;&gt;&lt;/ul&gt;&#10;  &lt;/div&gt;&#10;  &lt;div&gt;&#10;    &lt;h4&gt; Sohbet Geçmişi&lt;/h4&gt;&#10;    &lt;ul id=&quot;conversation-list&quot;&gt;&lt;/ul&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;&lt;hr&gt;&#10;&#10;&lt;label&gt;Alıcı: &lt;input type=&quot;text&quot; id=&quot;receiver&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#10;&lt;label&gt;Mesaj: &lt;input type=&quot;text&quot; id=&quot;message&quot; /&gt;&lt;/label&gt;&lt;br/&gt;&#10;&lt;button onclick=&quot;sendMessage()&quot;&gt;Gönder&lt;/button&gt;&#10;&#10;&lt;hr&gt;&#10;&lt;div id=&quot;chat-box&quot;&gt;&lt;/div&gt;&#10;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js&quot;&gt;&lt;/script&gt;&#10;&#10;&lt;script&gt;&#10;    let stompClient = null;&#10;    let currentUser = &quot;&quot;;&#10;&#10;    // URL'den kullanıcı adını al&#10;    const urlParams = new URLSearchParams(window.location.search);&#10;    currentUser = urlParams.get(&quot;user&quot;);&#10;&#10;    if (!currentUser) {&#10;      alert(&quot;Kullanıcı adı bulunamadı. Lütfen giriş yapın.&quot;);&#10;      window.location.href = &quot;/login.html&quot;;&#10;    }&#10;&#10;    document.getElementById(&quot;greeting&quot;).innerText = `${currentUser} olarak giriş yaptınız.`;&#10;&#10;    function connectWebSocket() {&#10;      const socket = new SockJS(&quot;/chat&quot;);&#10;      stompClient = Stomp.over(socket);&#10;&#10;      stompClient.connect({}, function () {&#10;        // Girişte önceki okunmamış mesajları da okundu olarak işaretle&#10;        fetch(`/messages/mark-all-read/${currentUser}`, { method: &quot;PUT&quot; });&#10;&#10;        stompClient.subscribe(&quot;/topic/messages/&quot; + currentUser, function (message) {&#10;          const msg = JSON.parse(message.body);&#10;          const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;          const chatBox = document.getElementById(&quot;chat-box&quot;);&#10;&#10;          // Eğer aynı mesaj daha önce eklendiyse tekrar gösterme&#10;          if (!document.getElementById(&quot;msg-&quot; + msg.id)) {&#10;            const p = document.createElement(&quot;p&quot;);&#10;            p.id = &quot;msg-&quot; + msg.id;&#10;            p.innerText = display;&#10;            chatBox.appendChild(p);&#10;          } else {&#10;            // Mevcutsa sadece status'ü güncelle&#10;            const existing = document.getElementById(&quot;msg-&quot; + msg.id);&#10;            existing.innerText = display;&#10;          }&#10;&#10;          // Eğer bu mesajın alıcısı bu kullanıcıysa ve henüz READ değilse → READ yap&#10;          if (msg.receiver === currentUser &amp;&amp; msg.status !== &quot;READ&quot;) {&#10;            fetch(`/messages/${msg.id}/read`, { method: &quot;PUT&quot; });&#10;          }&#10;        });&#10;&#10;        // Kullanıcı listelerini yükle&#10;        loadUserLists();&#10;      });&#10;    }&#10;&#10;    function loadUserLists() {&#10;      // Kişi listesi&#10;      fetch(`/users/all/${currentUser}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          const userList = document.getElementById(&quot;user-list&quot;);&#10;          userList.innerHTML = &quot;&quot;;&#10;          data.forEach(user =&gt; {&#10;            const li = document.createElement(&quot;li&quot;);&#10;            li.innerText = user;&#10;            li.style.cursor = &quot;pointer&quot;;&#10;            li.onclick = () =&gt; {&#10;              document.getElementById(&quot;receiver&quot;).value = user;&#10;              loadChatHistory(user);&#10;            };&#10;            userList.appendChild(li);&#10;          });&#10;        });&#10;&#10;      // Sohbet geçmişi&#10;      fetch(`/users/conversations/${currentUser}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          const convList = document.getElementById(&quot;conversation-list&quot;);&#10;          convList.innerHTML = &quot;&quot;;&#10;          data.forEach(user =&gt; {&#10;            const li = document.createElement(&quot;li&quot;);&#10;            li.innerText = user;&#10;            li.style.cursor = &quot;pointer&quot;;&#10;            li.onclick = () =&gt; {&#10;              document.getElementById(&quot;receiver&quot;).value = user;&#10;              loadChatHistory(user);&#10;            };&#10;            convList.appendChild(li);&#10;          });&#10;        });&#10;    }&#10;&#10;    function loadChatHistory(receiver) {&#10;      document.getElementById(&quot;chat-box&quot;).innerHTML = &quot;&quot;;&#10;&#10;      fetch(`/messages/${currentUser}/${receiver}`)&#10;        .then(res =&gt; res.json())&#10;        .then(data =&gt; {&#10;          data.forEach(msg =&gt; {&#10;            const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;            document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;          });&#10;        });&#10;    }&#10;&#10;    function sendMessage() {&#10;      if (!currentUser) {&#10;        alert(&quot;Giriş yapmadan mesaj gönderemezsiniz.&quot;);&#10;        return;&#10;      }&#10;&#10;      const receiver = document.getElementById(&quot;receiver&quot;).value;&#10;      const content = document.getElementById(&quot;message&quot;).value;&#10;&#10;      if (!receiver || !content) {&#10;        alert(&quot;Alıcı ve mesaj boş olamaz.&quot;);&#10;        return;&#10;      }&#10;&#10;      stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({&#10;        sender: currentUser,&#10;        receiver: receiver,&#10;        content: content&#10;      }));&#10;&#10;      // Mesaj kutusunu temizle&#10;      document.getElementById(&quot;message&quot;).value = &quot;&quot;;&#10;    }&#10;&#10;    connectWebSocket(); // Sayfa yüklenince otomatik bağlan&#10;&lt;/script&gt;&#10;&#10;&lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>