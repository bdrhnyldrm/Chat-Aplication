<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;@Configuration&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder(); //burada BCRYPT algoritması kullanarak şifreyi hashledik.&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf(csrf -&gt; csrf.disable())&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .anyRequest().permitAll()&#10;                );&#10;&#10;        return http.build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;@Configuration // Bu sınıfın bir Spring yapılandırma sınıfı olduğunu belirtir.&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        // Şifreleme için BCrypt algoritmasını kullanan bir PasswordEncoder bean'i tanımlar.&#10;        return new BCryptPasswordEncoder(); // Şifreleri güvenli bir şekilde hashlemek için kullanılır.&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        // Uygulamanın güvenlik yapılandırmasını tanımlar.&#10;        http&#10;                .csrf(csrf -&gt; csrf.disable()) // CSRF korumasını devre dışı bırakır (örnek amaçlı, üretimde dikkatli olunmalıdır).&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        .anyRequest().permitAll() // Tüm HTTP isteklerine izin verir (herkese açık erişim).&#10;                );&#10;&#10;        return http.build(); // Güvenlik yapılandırmasını oluşturur ve döndürür.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/config/WebSocketConfig.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.*;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        config.enableSimpleBroker(&quot;/topic&quot;); // mesaj dinleme kanalı&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;); // mesaj gönderme kanalı&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        registry.addEndpoint(&quot;/chat&quot;) // bağlantı noktası&#10;                .setAllowedOriginPatterns(&quot;*&quot;) // CORS&#10;                .withSockJS(); // SockJS fallback&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.config;&#10;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.web.socket.config.annotation.*;&#10;&#10;@Configuration // Bu sınıfın bir Spring yapılandırma sınıfı olduğunu belirtir.&#10;@EnableWebSocketMessageBroker // WebSocket mesajlaşma desteğini etkinleştirir.&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        config.enableSimpleBroker(&quot;/topic&quot;); // Mesajların dinleneceği kanalın ön ekini tanımlar.&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;); // Mesajların gönderileceği kanalın ön ekini tanımlar.&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        registry.addEndpoint(&quot;/chat&quot;) // WebSocket bağlantısı için kullanılacak endpoint'i tanımlar.&#10;                .setAllowedOriginPatterns(&quot;*&quot;) // CORS yapılandırması: Tüm kaynaklara izin verir.&#10;                .withSockJS(); // SockJS desteği ekler, WebSocket desteklenmeyen tarayıcılar için yedek çözüm.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/ChatController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/ChatController.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.messaging.handler.annotation.*;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.stereotype.Controller;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Controller&#10;public class ChatController {&#10;&#10;    @Autowired&#10;    private SimpMessagingTemplate messagingTemplate;&#10;&#10;    @Autowired&#10;    private ChatMessageRepository chatMessageRepository;&#10;&#10;    @MessageMapping(&quot;/chat&quot;) // → /app/chat üzerinden dinler&#10;    public void sendMessage(@Payload ChatMessage message) {&#10;        message.setTimestamp(LocalDateTime.now());&#10;        message.setStatus(&quot;SENT&quot;);&#10;&#10;        chatMessageRepository.save(message);&#10;&#10;        // Gönderilen mesajı, alıcıya ilet&#10;        messagingTemplate.convertAndSend(&#10;                &quot;/topic/messages/&quot; + message.getReceiver(),&#10;                message&#10;        );&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.messaging.handler.annotation.*;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.stereotype.Controller;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Controller // Bu sınıfın bir Spring Controller olduğunu belirtir.&#10;public class ChatController {&#10;&#10;    @Autowired // Spring tarafından SimpMessagingTemplate bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private SimpMessagingTemplate messagingTemplate; // Mesajları belirli bir hedefe göndermek için kullanılır.&#10;&#10;    @Autowired // Spring tarafından ChatMessageRepository bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private ChatMessageRepository chatMessageRepository; // Mesajları veritabanına kaydetmek için kullanılır.&#10;&#10;    @MessageMapping(&quot;/chat&quot;) // Gelen mesajları /app/chat endpoint'inde dinler.&#10;    public void sendMessage(@Payload ChatMessage message) {&#10;        message.setTimestamp(LocalDateTime.now()); // Mesajın gönderildiği zamanı ayarlar.&#10;        message.setStatus(&quot;SENT&quot;); // Mesajın durumunu &quot;SENT&quot; olarak ayarlar.&#10;&#10;        chatMessageRepository.save(message); // Mesajı veritabanına kaydeder.&#10;&#10;        // Gönderilen mesajı, alıcının dinlediği kanala iletir.&#10;        messagingTemplate.convertAndSend(&#10;                &quot;/topic/messages/&quot; + message.getReceiver(), // Alıcının dinlediği kanal.&#10;                message // Gönderilecek mesaj.&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/MessageRestController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/controller/MessageRestController.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;&#10;@RestController // Bu sınıfın bir REST API denetleyicisi olduğunu belirtir.&#10;@RequestMapping(&quot;/messages&quot;) // Bu denetleyiciye gelen isteklerin &quot;/messages&quot; yoluyla eşleşeceğini belirtir.&#10;public class MessageRestController {&#10;&#10;    @Autowired // Spring tarafından ChatMessageRepository bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private ChatMessageRepository chatMessageRepository; // Mesajları veritabanından almak için kullanılır.&#10;&#10;    @GetMapping(&quot;/{user1}/{user2}&quot;) // İki kullanıcı arasındaki mesaj geçmişini almak için bir GET endpoint tanımlar.&#10;    public List&lt;ChatMessage&gt; getChatHistory(@PathVariable String user1, @PathVariable String user2) {&#10;        // user1 ve user2 parametreleri URL'den alınır.&#10;&#10;        List&lt;ChatMessage&gt; sent = chatMessageRepository.findBySenderAndReceiver(user1, user2);&#10;        // user1'in user2'ye gönderdiği mesajları alır.&#10;&#10;        List&lt;ChatMessage&gt; received = chatMessageRepository.findBySenderAndReceiver(user2, user1);&#10;        // user2'nin user1'e gönderdiği mesajları alır.&#10;&#10;        sent.addAll(received); // Gönderilen ve alınan mesajları birleştirir.&#10;        sent.sort(Comparator.comparing(ChatMessage::getTimestamp));&#10;        // Mesajları zaman damgasına göre sıralar (en eski mesajdan en yeni mesaja).&#10;&#10;        return sent; // Sıralanmış mesaj listesini döndürür.&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}/read&quot;)&#10;    public ResponseEntity&lt;String&gt; markAsRead(@PathVariable Long id) {&#10;        return chatMessageRepository.findById(id)&#10;            .map(msg -&gt; {&#10;                msg.setStatus(&quot;READ&quot;);&#10;                chatMessageRepository.save(msg);&#10;                return ResponseEntity.ok(&quot;Mesaj okundu olarak işaretlendi&quot;);&#10;            })&#10;            .orElse(ResponseEntity.notFound().build());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.controller;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import com.chatapp.realtime_chat.repository.ChatMessageRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;&#10;import java.util.Comparator;&#10;import java.util.List;&#10;&#10;@RestController // Bu sınıfın bir REST API denetleyicisi olduğunu belirtir.&#10;@RequestMapping(&quot;/messages&quot;) // Bu denetleyiciye gelen isteklerin &quot;/messages&quot; yoluyla eşleşeceğini belirtir.&#10;public class MessageRestController {&#10;&#10;    @Autowired // Spring tarafından ChatMessageRepository bean'inin otomatik olarak bağlanmasını sağlar.&#10;    private ChatMessageRepository chatMessageRepository; // Mesajları veritabanından almak için kullanılır.&#10;&#10;    @GetMapping(&quot;/{user1}/{user2}&quot;) // İki kullanıcı arasındaki mesaj geçmişini almak için bir GET endpoint tanımlar.&#10;    public List&lt;ChatMessage&gt; getChatHistory(@PathVariable String user1, @PathVariable String user2) {&#10;        // user1 ve user2 parametreleri URL'den alınır.&#10;&#10;        List&lt;ChatMessage&gt; sent = chatMessageRepository.findBySenderAndReceiver(user1, user2);&#10;        // user1'in user2'ye gönderdiği mesajları alır.&#10;&#10;        List&lt;ChatMessage&gt; received = chatMessageRepository.findBySenderAndReceiver(user2, user1);&#10;        // user2'nin user1'e gönderdiği mesajları alır.&#10;&#10;        sent.addAll(received); // Gönderilen ve alınan mesajları birleştirir.&#10;        sent.sort(Comparator.comparing(ChatMessage::getTimestamp));&#10;        // Mesajları zaman damgasına göre sıralar (en eski mesajdan en yeni mesaja).&#10;&#10;        return sent; // Sıralanmış mesaj listesini döndürür.&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}/read&quot;)&#10;    public ResponseEntity&lt;String&gt; markAsRead(@PathVariable Long id) {&#10;        return chatMessageRepository.findById(id)&#10;            .map(msg -&gt; {&#10;                msg.setStatus(&quot;READ&quot;);&#10;                chatMessageRepository.save(msg);&#10;                return ResponseEntity.ok(&quot;Mesaj okundu olarak işaretlendi&quot;);&#10;            })&#10;            .orElse(ResponseEntity.notFound().build());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/model/ChatMessage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/model/ChatMessage.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;@Table(name = &quot;messages&quot;)&#10;public class ChatMessage {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    private String sender;&#10;    private String receiver;&#10;    private String content;&#10;&#10;    private LocalDateTime timestamp;&#10;&#10;    private String status; // örn: SENT, DELIVERED, READ&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.*;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity // Bu sınıfın bir JPA varlık sınıfı olduğunu belirtir.&#10;@Data // Lombok tarafından getter, setter, toString, equals ve hashCode metodlarını otomatik oluşturur.&#10;@NoArgsConstructor // Parametresiz bir yapıcı metod oluşturur.&#10;@AllArgsConstructor // Tüm alanları içeren bir yapıcı metod oluşturur.&#10;@Builder // Builder tasarım desenini kullanarak nesne oluşturmayı sağlar.&#10;@Table(name = &quot;messages&quot;) // Bu varlığın veritabanında &quot;messages&quot; tablosuna karşılık geldiğini belirtir.&#10;public class ChatMessage {&#10;&#10;    @Id // Bu alanın birincil anahtar olduğunu belirtir.&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY) // Birincil anahtarın otomatik olarak artırılacağını belirtir.&#10;    private Long id; // Mesajın benzersiz kimliği.&#10;&#10;    private String sender; // Mesajı gönderen kişinin kullanıcı adı veya kimliği.&#10;    private String receiver; // Mesajın alıcısının kullanıcı adı veya kimliği.&#10;    private String content; // Mesajın içeriği.&#10;&#10;    private LocalDateTime timestamp; // Mesajın gönderildiği tarih ve saat.&#10;&#10;    private String status; // Mesajın durumu (örneğin: SENT, DELIVERED, READ).&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/repository/ChatMessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/java/com/chatapp/realtime_chat/repository/ChatMessageRepository.java" />
              <option name="originalContent" value="package com.chatapp.realtime_chat.repository;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.List;&#10;&#10;public interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;&#10;    List&lt;ChatMessage&gt; findBySenderAndReceiver(String sender, String receiver);&#10;&#10;    List&lt;ChatMessage&gt; findByReceiverAndSender(String receiver, String sender);&#10;}&#10;" />
              <option name="updatedContent" value="package com.chatapp.realtime_chat.repository;&#10;&#10;import com.chatapp.realtime_chat.model.ChatMessage;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.List;&#10;&#10;public interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;    // JpaRepository, ChatMessage varlığı için temel CRUD işlemlerini sağlar.&#10;&#10;    List&lt;ChatMessage&gt; findBySenderAndReceiver(String sender, String receiver);&#10;    // Belirli bir gönderici ve alıcı arasındaki mesajları döndürür.&#10;&#10;    List&lt;ChatMessage&gt; findByReceiverAndSender(String receiver, String sender);&#10;    // Belirli bir alıcı ve gönderici arasındaki mesajları döndürür (ters yönlü sorgu).&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/realtime-chat/src/main/resources/static/chat.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/realtime-chat/src/main/resources/static/chat.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Gerçek Zamanlı Sohbet&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;h2&gt;Gerçek Zamanlı Mesajlaşma&lt;/h2&gt;&#10;&#10;&lt;label&gt; Kullanıcı Adı: &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;&lt;/label&gt; &lt;!-- Kullanıcı adını girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;label&gt; Alıcı: &lt;input type=&quot;text&quot; id=&quot;receiver&quot; /&gt;&lt;/label&gt; &lt;!-- Mesajın gönderileceği alıcıyı girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;label&gt;✏️ Mesaj: &lt;input type=&quot;text&quot; id=&quot;message&quot; /&gt;&lt;/label&gt; &lt;!-- Gönderilecek mesajı girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;button onclick=&quot;connect()&quot;&gt; Bağlan&lt;/button&gt; &lt;!-- WebSocket bağlantısını başlatan buton --&gt;&#10;&lt;button onclick=&quot;sendMessage()&quot;&gt; Gönder&lt;/button&gt; &lt;!-- Mesaj göndermek için kullanılan buton --&gt;&#10;&#10;&lt;hr&gt;&#10;&lt;div id=&quot;chat-box&quot;&gt;&lt;/div&gt; &lt;!-- Gelen mesajların görüntüleneceği alan --&gt;&#10;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; &lt;!-- SockJS kütüphanesi --&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js&quot;&gt;&lt;/script&gt; &lt;!-- STOMP protokolü için kütüphane --&gt;&#10;&#10;&lt;script&gt;&#10;    let stompClient = null; // STOMP istemcisi&#10;    let username = &quot;&quot;; // Kullanıcı adı&#10;&#10;    function connect() {&#10;        username = document.getElementById(&quot;username&quot;).value; // Kullanıcı adını alır&#10;&#10;        const socket = new SockJS(&quot;/chat&quot;); // SockJS bağlantısını başlatır&#10;        stompClient = Stomp.over(socket); // STOMP istemcisini oluşturur&#10;&#10;        stompClient.connect({}, function () {&#10;            alert(username + &quot; olarak bağlandın!&quot;); // Bağlantı başarılı olduğunda kullanıcıya bilgi verir&#10;&#10;            fetch(`/messages/${username}/${document.getElementById(&quot;receiver&quot;).value}`)&#10;                .then(response =&gt; response.json())&#10;                .then(data =&gt; {&#10;                    data.forEach(msg =&gt; {&#10;                        const display = msg.sender + &quot;: &quot; + msg.content;&#10;                        document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;                    });&#10;                });&#10;&#10;            stompClient.subscribe(&quot;/topic/messages/&quot; + username, function (message) {&#10;                const msg = JSON.parse(message.body);&#10;                const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;                document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;&#10;                // Okundu durumunu backend'e bildir&#10;                fetch(`/messages/${msg.id}/read`, {&#10;                    method: &quot;PUT&quot;&#10;                });&#10;            });&#10;        });&#10;    }&#10;&#10;    function sendMessage() {&#10;        const content = document.getElementById(&quot;message&quot;).value; // Mesaj içeriğini alır&#10;        const receiver = document.getElementById(&quot;receiver&quot;).value; // Alıcı bilgisini alır&#10;&#10;        stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({&#10;            sender: username, // Mesajı gönderen kullanıcı&#10;            receiver: receiver, // Mesajın alıcısı&#10;            content: content // Mesajın içeriği&#10;        })); // Mesajı sunucuya gönderir&#10;    }&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;en&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;title&gt;Gerçek Zamanlı Sohbet&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;h2&gt;Gerçek Zamanlı Mesajlaşma&lt;/h2&gt;&#10;&#10;&lt;label&gt; Kullanıcı Adı: &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;&lt;/label&gt; &lt;!-- Kullanıcı adını girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;label&gt; Alıcı: &lt;input type=&quot;text&quot; id=&quot;receiver&quot; /&gt;&lt;/label&gt; &lt;!-- Mesajın gönderileceği alıcıyı girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;label&gt;✏️ Mesaj: &lt;input type=&quot;text&quot; id=&quot;message&quot; /&gt;&lt;/label&gt; &lt;!-- Gönderilecek mesajı girmek için giriş alanı --&gt;&#10;&lt;br/&gt;&#10;&lt;button onclick=&quot;connect()&quot;&gt; Bağlan&lt;/button&gt; &lt;!-- WebSocket bağlantısını başlatan buton --&gt;&#10;&lt;button onclick=&quot;sendMessage()&quot;&gt; Gönder&lt;/button&gt; &lt;!-- Mesaj göndermek için kullanılan buton --&gt;&#10;&#10;&lt;hr&gt;&#10;&lt;div id=&quot;chat-box&quot;&gt;&lt;/div&gt; &lt;!-- Gelen mesajların görüntüleneceği alan --&gt;&#10;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; &lt;!-- SockJS kütüphanesi --&gt;&#10;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js&quot;&gt;&lt;/script&gt; &lt;!-- STOMP protokolü için kütüphane --&gt;&#10;&#10;&lt;script&gt;&#10;    let stompClient = null; // STOMP istemcisi&#10;    let username = &quot;&quot;; // Kullanıcı adı&#10;&#10;    function connect() {&#10;        username = document.getElementById(&quot;username&quot;).value; // Kullanıcı adını alır&#10;&#10;        const socket = new SockJS(&quot;/chat&quot;); // SockJS bağlantısını başlatır&#10;        stompClient = Stomp.over(socket); // STOMP istemcisini oluşturur&#10;&#10;        stompClient.connect({}, function () {&#10;            alert(username + &quot; olarak bağlandın!&quot;); // Bağlantı başarılı olduğunda kullanıcıya bilgi verir&#10;&#10;            fetch(`/messages/${username}/${document.getElementById(&quot;receiver&quot;).value}`)&#10;                .then(response =&gt; response.json())&#10;                .then(data =&gt; {&#10;                    data.forEach(msg =&gt; {&#10;                        const display = msg.sender + &quot;: &quot; + msg.content;&#10;                        document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;                    });&#10;                });&#10;&#10;            stompClient.subscribe(&quot;/topic/messages/&quot; + username, function (message) {&#10;                const msg = JSON.parse(message.body);&#10;                const display = `${msg.sender}: ${msg.content} (${msg.status})`;&#10;                document.getElementById(&quot;chat-box&quot;).innerHTML += `&lt;p&gt;${display}&lt;/p&gt;`;&#10;&#10;                // Eğer mesaj zaten READ ise tekrar okundu olarak işaretleme&#10;                if (msg.status !== &quot;READ&quot;) {&#10;                    fetch(`/messages/${msg.id}/read`, {&#10;                        method: &quot;PUT&quot;&#10;                    });&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    function sendMessage() {&#10;        const content = document.getElementById(&quot;message&quot;).value; // Mesaj içeriğini alır&#10;        const receiver = document.getElementById(&quot;receiver&quot;).value; // Alıcı bilgisini alır&#10;&#10;        stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({&#10;            sender: username, // Mesajı gönderen kullanıcı&#10;            receiver: receiver, // Mesajın alıcısı&#10;            content: content // Mesajın içeriği&#10;        })); // Mesajı sunucuya gönderir&#10;    }&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>